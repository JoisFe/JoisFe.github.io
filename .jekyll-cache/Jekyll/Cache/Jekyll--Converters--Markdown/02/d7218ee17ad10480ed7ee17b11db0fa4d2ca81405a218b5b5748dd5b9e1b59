I"4<h2 id="iocinversion-of-control-제어의-역전">IoC(Inversion of Control) 제어의 역전</h2>
<p>기존의 프로그램 경우 클라이언트 구현 객체가 스스로 필요한 서버 구현 객체를 생성, 연결, 실행 하였다.<br />
즉 구현 객체가 프로그램의 제어 흐름을 스스로 조종했다는 의미이다. <br />
개발자 입장에서 보자면 자연스러운 흐름으로 보인다. <br />
<br /></p>

<p>반면에 이전에 설계한 것을 보면 AppConfig를 이용한 후 부터 구현 객체는 자신의 로직을 실행하는 역할만 담당하지 다른 역할을 할 필요가 없어졌다. <br /> 
프로그램의 제어 흐름을 AppConfig가 가져가게 된 것이다. <br />
예를들면 OrderServiceImpl은 필요한 인터페이스들을 호출하지만 어떤 구현 객체들이 실행될지 모른다. <br /><br /></p>

<p>프로그램에 대한 제어 흐름에 대한 권한은 모두 AppConfig가 가지고 있다. <br />
심지어 OrderServiceImpl도 AppConfig가 생성 하였다. <br />
그리고 AppConfig는 OrderServiceImpl이 아니라 OrderService 인터페이스의 다른 구현 객체를 생성할 수도 실행할 수도 있다.<br /><br /></p>

<p>-&gt; 프로그램의 제어 흐름을 직접 제어하는 것이 아니라 외부에서 관리하는 것을 <b>제어의 역전(IoC)</b>이라고 한다.
<br /><br /></p>

<p>IoC에 대해 알아 보았는데 여기서 지금까지의 목적인 “스프링 프레임워크를 왜 쓰게 되었는지?” 에 대한 의문이 살짝 나왔다.<br />
그 부분을 알기 위해 프레임 워크와 라이브러리 차이를 알아보고자 한다. <br /></p>
<h3 id="프레임워크-vs-라이브러리">프레임워크 vs 라이브러리</h3>
<p>프레임워크 : 자신이 작성한 코드를 제어하고, 대신 실행 ex) JUnit
라이브러리 : 자신이 작성한 코드가 직접 제어의 흐름을 담당
<br /><br />
AppConfig가 프로그램의 제어 흐름, 제어 흐름에 대한 권한을 가졌는데 이 부분이 결국 우리가 스프링 프레임워크를 쓰게된 이유와 크게 관련이 되어있지 않을까??? 라는 생각을 할 수있다.
<br /><br /></p>

<h2 id="didependency-injection-의존관계-주입">DI(Dependency Injection) 의존관계 주입</h2>
<p>OrderServiceImpl은 DiscountPolicy 인터페이스에 의존한다.<br />
OrderserviceImpl은 DiscountPolicy에 실제로 어떤 구현 객체가 사용되었는지 알 수 없다.<br />
<b>의존관계</b>는 정적인 클래스 의존관계와 실행 시점에 결정되는 동적인 객체(인스턴스) 의존 관계 들을 분리해서 생각해야 한다. <br /><br /></p>

<h3 id="정적인-클래스-의존관계">정적인 클래스 의존관계</h3>
<p>클래스가 사용하는 import 코드만 보고 의존관계를 쉽게 판단할 수 있다. <br />
따라서 정적인 의존관계는 애플리케이션을 실행하지 않아도 분석할 수 있다.<br /></p>

<p>아래 클래스 다이어그램을 보자<br /></p>
<h3 id="클래스-다이어그램">클래스 다이어그램</h3>
<p><img src="/images/Spring_basic(9)_files/주문 도메인 클래스 다이어그램.jpeg" alt="jpeg" />
<br />
OrderServiceImpl은 MemberRepository, DiscountPolicy에 의존한다는 것을 확인할 수 있다. <br />
그러나 이러한 클래스 의존관계 만으로는 실제 어떤 객체가 OrderServiceImpl에 주입될지 알 수 없다. <br />
즉 OrderServiceImpl는 자신이 의존하는 인퍼페이스인  MemberRepository에 구현 객체가 MemoryMemberRepository가 사용되었을지 DbMemberRepository가 사용되었을지 알 수 없다.<br />
마찬가지로 OrderServiceImpl은 자신이 의존하는 인터페이스인 DiscountPolicy에 구현 객체가 FixDiscountPolicy가 사용될지 RateDiscountPolicy가 사용될지 모른다. <br /><br /></p>

<h3 id="동적인-객체-인스턴스-의존관계">동적인 객체 인스턴스 의존관계</h3>
<p>애플리케이션 실행 시점에 실제 생성된 객체 인스턴스의 참조가 연결된 의존관계를 말한다.<br />
아래 객체 다이어그램을 보자<br /></p>
<h3 id="객체-다이어그램">객체 다이어그램</h3>
<p><img src="/images/Spring_basic(9)_files/주문 도메인 객체 다이어그램1.jpeg" alt="jpeg" />
<br />
애플리케이션 실행 시점(런타임)에 외부(AppConfig)에서 실제 구현 객체를 생성하고 클라이언트에 전달해서 클라이언트와 서버의 실제 의존관계가 연결 되는 것을 <b>의존관계 주입</b>이라고 한다. <br />
객체 인스턴스를 생성하고 그 참조값을 전달해서 연결된다.<br />
의존관계 주입을 사용하면 클라이언트 코드를 변경하지 않고 클라이언트가 호출하는 대상의 타입 인스턴스를 변경할 수 있게 된다. <br />
의존관계 주입을 사용하면 정적인 클래스 의존관계를 변경하지 않고 동적인 객체 인스턴스 의존관계를 쉽게 변경할 수 있다.<br />
-&gt; 정적인 클래스 의존관계를 변경하지 않아도 된다는 말은 이전에 그림으로 보인 클래스 다이어그램을 변경하지 않아도 된다는 의미이고 그 뜻은 애플리케이션 코드를 변경하지 않아도 된다는 말과 같다. <br />
 -&gt; 동적인 객체 인스턴스 의존관계를 바꾸는 것은 이전에 그림으로 보인 객체 다이어그램을 변경하는것을 말하고 외부(AppConfig) 코드만 건드리고(변경) 실제 애플리케이션 코드는 변경하지 않아도 된다.<br /><br /></p>

<h2 id="ioc-컨테이너-di-컨테이너">IoC 컨테이너, DI 컨테이너</h2>
<p>AppConfig처럼 객체를 생성하고 관리하면서 의존관계를 연결해 주는 것을 <b>IoC 컨테이너</b> 혹은 <b>DI 컨테이너</b> 라고 부른다. <br />
<br />
의존관계 주입에 초점을 맞추어 최근에는 주로 <b>DI 컨테이너</b>라고 부른다. <br />
또는 <b>어셈블러</b>, <b>오브젝트 팩토리</b> 등으로 불리기도 한다.</p>

<p><br /><br /></p>

<p>자 지금까지 순수 자바로만 설계를 해왔다. <br />
다음에는 Spring 프레임워크를 이용해보자. <br />
어떤게 더 도움이 되길래 굳이 쓸까??? 한번 알아보자 <br /><br /></p>

<h3 id="reference-">Reference :</h3>
<p>김영한 강사님 스프링 핵심 원리 - 기본편  강의 중</p>
:ET